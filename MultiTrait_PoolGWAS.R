# Two-dimensional Scheme

#(1) install and load the packages.

# Note that, it is necessary to have 'snpStats' 
# to install 'PhenotypeSimulator'.
# So, if you don't have snpStats, install it using
# the following command.


if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
BiocManager::install("snpStats", force = T)
install.packages('PhenotypeSimulator')

# now load the packages. If you don't have any of the below mentioned packages, install it accordingly.
library(PhenotypeSimulator)
library(dplyr)
library(ggplot2)
library(readr)
library(stabs)

#(2) Generating Phenotypes:-
# Generating 2-dimensional phenotype (so, P=2) with 3 components, viz. genetic effects, polygenic effects,
# and environmental noise. There is no covariaye effect (hence 'delta'=0) and no correlated noise (hence 'rho'=0).
# Total no. of individuals (N) =2000, total no. of SNPs (tNrSNP)= 10000, no. of causal SNPs (cNrSNP) =10.
# Total genetic heritability (genVar)=60%, SNP heritability=50%. Note that SNP heritability is controlled by 'genVar * h2s'.
# So, h2s=0.5/0.6. We randomly select 2 SNPs out of 10  to be causal for both the traits (i.e. pleitropic SNPs or SNPs having shared effect);
# and this quantity is controlled by '1-pIndependerGenetic'. So we set '1-pIndependerGenetic'=2/10=0.2 or 'pIndependerGenetic'=0.8.
# 'pTraitIndependentGenetic = 0.5' means that the remaining 8 SNPs are randomly selected to be causal for only one trait (i.e 1 out of 2 traits. Hence 1/2=0.5 appears)
# 'SNPfrequencies' denote the set of MAFs. MAF of a particular SNP is randomly selected from this set of MAFs.

phenotype=runSimulation(N=2000, P=2, genVar=0.6,
                        h2s=0.5/0.6, rho=0, delta=0, tNrSNP=10000,
                        cNrSNP=10, SNPfrequencies=c(0.05, 0.1,0.2),
                        pIndependentGenetic = 0.8,
                        pTraitIndependentGenetic = 0.5, seed=16 )



# now we will find the pleitropic SNPs and trait-specific Independent SNPs generated by 'PhenotypeSimulator'.

fixedGen=phenotype[["phenoComponentsIntermediate"]][["genFixed"]]
snpscombined=as.data.frame(t(fixedGen$cov_effect))
pleitropicsnps=rownames(snpscombined %>% filter(  (!(Trait_1 ==0)) & (!(Trait_2==0)) ))         
snps_causal_trait1=rownames(snpscombined %>% filter(  (!(Trait_1 ==0)) & (Trait_2==0)  ))         
snps_causal_trait2=rownames(snpscombined %>% filter(  (Trait_1==0)    & (!(Trait_2 ==0))  ))         
getshared=function(char){
  return( substring(char, 28, nchar(char))       )
}

# 'pleitropicsnps' below is a vector of the two pleitropic SNPs
pleitropicsnps=sapply(pleitropicsnps, getshared) 
getindependent=function(char){
  return( substring(char, 38, nchar(char))       )
}

# SNPs which are causal only for Trait 1:-
snps_causal_trait1=unname(sapply(snps_causal_trait1, getindependent)) # these are SNPs only causal for Trait 1

# SNPs which are only causal for Trait 2:-
snps_causal_trait2=unname(sapply(snps_causal_trait2, getindependent)) # these are SNPs only causal for Trait 2

# The totality of 10 causal SNPs:-
causal_snps=colnames(fixedGen[["cov"]])

# the N by 2 phenotype matrix(each column of the matrix is obs. on one trait):-

Y=as.data.frame(phenotype[["phenoComponentsFinal"]][["Y"]])

# plot scatter plot of the two traits:-

ggplot(Y, aes(x=Trait_1, y=Trait_2)) + geom_point()



#(3) Clustering scheme :- division into K * L equi-sized clusters based on quantiles:-

K=7
L=K # we plan to divide both the traits into 7 bins based on quantile (hence L=K). You can also divide Trait 1 into
# 7 bins, and Trait 2 into 5 bins, say, which will result in 35 clusters.

probs_1=seq(0,1, by=1/K) # we want the area between the quantiles to be same (1/K in this case)
probs_2=seq(0,1, by=1/L) 

# quantiles of Trait-1 at probability specified in 'probs_1':-
quantile_1=quantile(Y$Trait_1, probs=probs_1) 


# Below 'clusters_trait1' is the list of K clusters (almost same sizes)
# obtained by quantile based clustering of Trait_1:-
clusters_trait1=list()
for(i in 1:(length(probs_1)-1)){
  if(i < (length(probs_1)-1)){
    clusters_trait1[[i]]=Y %>%  filter( (Trait_1>=quantile_1[i]) & (Trait_1<quantile_1[i+1]) )
  }
  else{
    clusters_trait1[[i]]=Y %>%  filter( (Trait_1>=quantile_1[i]) & (Trait_1<=quantile_1[i+1]) )  
  }
}

# The following function will do quantile based clustering based on Trait_2 and return a list 
# for each of the element of the above list 'clusters_trait1':-

getclusters_trait2=function(df){
  temp_list=list()
  temp_quantile=quantile(df$Trait_2, probs=probs_2)
  for(i in 1:(length(probs_2)-1)){
    if(i< (length(probs_2)-1)){
      temp_list[[i]]=df %>%  filter( (Trait_2>=temp_quantile[i]) & (Trait_2<temp_quantile[i+1]) )
    }
    else{
      temp_list[[i]]=df %>%  filter( (Trait_2>=temp_quantile[i]) & (Trait_2<=temp_quantile[i+1]) )
    }
  }
  return(temp_list)
}

clusters_traits=list()
for(i in 1:length(clusters_trait1)){
  temp=getclusters_trait2(clusters_trait1[[i]])
  clusters_traits=append(clusters_traits, temp)
}

# finally all the K*L clusters presenetd in terms of individual ids:-

clusters=lapply(clusters_traits, rownames) # it will be a list, each denoting the cluster of individuals' ID belonging to a particular cluster

# N by S(=total no. of SNPs) allele frequency matrix:-
genotypes=as.data.frame(phenotype[["rawComponents"]][["genotypes"]][["genotypes"]])


#(4) Assigning true genotypes to clusters created:-

# The following function will create a list of clusters. But this time each element of the list will contain
# the genotypes of the individuals belonging to that cluster. The argument 'clusters' is the list of K*L clusters 
# of individual IDs obtained above. 'genotype' should be the the allele frequency matrix.

cls_genotype=function(clusters, genotype){
  k=length(clusters)
  l=list()
  for(i in 1:k){
    l[[i]]= genotype %>% filter(row.names(genotype) %in% clusters[[i]]        ) 
    
  } 
  
  return(l)  
}

# clusters_genotype is list of clusters of genotypes:-

clusters_genotype=cls_genotype(clusters, genotypes)

#(5) Getting Pooled allele frequencies (PAF):-

# The following function returns the PAF of a paricular SNP
# in all the pools. The output is a vector whose ith element is PAF of 
# the snp in ith pool. Argument 'clusters_genotype' should be the 
# output of the 'cls_genotype' function. The next argument 'snp' should be
# a character string denoting the SNP, for e.g., 'SNP_111', 'SNP_176' etc. 

pool_allele_freq1=function(clusters_genotype, snp){
  k=length(clusters_genotype)
  a=rep(0,k)
  for(i in 1:k){
    a[i]=sum(clusters_genotype[[i]][,snp])/(2*(nrow(clusters_genotype[[i]]))) 
  }
  return(a) 
}

SNPs=phenotype[["setup"]][["id_snps"]] # denote the IDs of the SNPs.

# the following object 'allele_freq1' is pooled allele frequency matrix
# whose rows denote the pools, and columns denote the SNPs. 
allele_freq1=matrix(NA, nrow=length(clusters), ncol=length(SNPs))
for(i in 1:length(SNPs)){
  allele_freq1[,i]=pool_allele_freq1(clusters_genotype = clusters_genotype, snp=SNPs[i])  
}
colnames(allele_freq1)=SNPs


#(6) Regenaration

# Now coming to regenerating the genotype data from 
# these pooled allele frequencies. We compressed our genotype data to
# allele frequencies. Now we will expand again by regeneration.
# The ideal thing will be to regenerate same number of individuals
# per cluster whose genotype we combined to get the allele frequency

ind_percluster=sapply(clusters_genotype, nrow) # denotes no. of individuals per cluster

# 'clusters_genotype_re' below is a list where i th element of the list
# will be a dataframe with first column all i's (that is, the cluster number)
# and rest columns will denote regenerated allele frequencies for all the SNPs
# in cluster i 

clusters_genotype_re=list()
set.seed(156) # set this seed to have the reproducible regenerated data
for(i in 1:length(clusters)){
  a=ind_percluster[i]
  y=rep(i,a)
  
  d=matrix(NA, nrow=a, ncol=length(SNPs))
  for(j in 1:length(SNPs)){
    d[,j]= rbinom(a,2, allele_freq1[i,j])
    
  }
  
  clusters_genotype_re[[i]]=cbind(y,d)
  
}

# the object 'data_regenerate' below is the regenerated genotype data from the pooled
# allele frequencies. The first column of this data denotes the cluster numbers.
# So we can use this data for classification purpose, say, random forest. 
# But be sure to shuffle the data before applying to random forest

data_regenerate=clusters_genotype_re[[1]]
for(i in 2:length(clusters_genotype_re)){
  data_regenerate=rbind(data_regenerate,clusters_genotype_re[[i]] )
}

data_regenerate=as.data.frame(data_regenerate)

colnames(data_regenerate)[2:ncol(data_regenerate)]=SNPs


#(7) Assign the available phenotypes to the regenerated genotypes in an arbitrary order

# clus_pheno below denote a list of K*L  clusters containing phenotype observations
clus_pheno=list()
for(i in 1:length(clusters)){
  clus_pheno[[i]]=Y %>% filter(rownames(Y) %in% clusters[[i]])
}

# 'clusters_genphen_re' below is a list with i th element denoting the a dataframe 
# whose first two columns will be the phenotype observations for all the individuals
# in i th pool, and rest of the columns denoting regenerated allele freq. of all SNPs
# for i th pool. 
clusters_genphen_re=list()
for(i in 1:length(clusters_genotype_re)){
  clusters_genphen_re[[i]]=cbind( clus_pheno[[i]]$Trait_1, clus_pheno[[i]]$Trait_2,  clusters_genotype_re[[i]][, 2:ncol(data_regenerate)]         )
  
}

# the object 'data_combined_re' below will be the regenerated genotype data from the pooled
# allele frequencies. It is same as 'data_regenerate', except that now we have phenotype observations
# in the first two columns. Whereas, in 'data_regenerate' there were no phenotypes, and first column there 
# was the cluster assignments. 
# We will use 'data_combined_re' for running LASSO.

data_combined_re=clusters_genphen_re[[1]]
for(i in 2:length(clusters_genphen_re)){
  data_combined_re=rbind(data_combined_re,clusters_genphen_re[[i]] )
}
data_combined_re=as.data.frame(data_combined_re)
colnames(data_combined_re)=c('y_1','y_2', SNPs)


#(8) LASSO+Stability selection

n0=nrow(data_combined_re) #no. of observations==no. of individuals
data_combined_re=data_combined_re[sample(1:n0, size=n0),] # shuffling the rows
x=data_combined_re[,3:ncol(data_combined_re)] # the feature matrix
y1=data_combined_re$y_1 # Trait 1 observations
y2=data_combined_re$y_2 # Trait 2 observations

# LASSO + Stability selection for Trait 1:-
# Below We use 'Original Stability Selection' with tau=0.8 and PFER=0.5. 
# For using CPSS, just change 'sampling.type=SS' and 'assumption=r-concave' in the function below.

stab.lasso=stabsel(x=x, y=y1, intercept=F, fitfun=glmnet.lasso,
                   cutoff=0.8, PFER=0.5, assumption="none",
                   sampling.type="MB")

temp1=stab.lasso[["selected"]] # vector of selected variables (or, IDs of selected SNPs)
length(temp1) # total number of discovery
sum(parse_number(causal_snps)%in%temp1) # no. of causal SNPs captured by performing LASSO+ Stab. Selection to Trait 1
sum(parse_number(pleitropicsnps) %in% temp1) # no. of 'pleitropic causal SNPs' captured by performing LASSO+ Stab. Selection to Trait 1
sum(parse_number(snps_causal_trait1) %in% temp1) # no. of 'causal for Trait 1 only SNPs' captured by performing LASSO+ Stab. Selection to Trait 1

# LASSO+ Stab. Selection for Trait 2:-

stab.lasso=stabsel(x=x, y=y2, intercept=F, fitfun=glmnet.lasso,
                   cutoff=0.8, PFER=0.5, assumption="none",
                   sampling.type="MB")

temp2=stab.lasso[["selected"]] # vector of selected variables (or, IDs of selected SNPs)
length(temp2) # total number of discovery
sum(parse_number(causal_snps)%in%temp2) # no. of causal SNPs captured by performing LASSO+ Stab. Selection to Trait 2
sum(parse_number(pleitropicsnps) %in% temp2) # no. of 'pleitropic causal SNPs' captured by performing LASSO+ Stab. Selection to Trait 2
sum(parse_number(snps_causal_trait1) %in% temp2) # no. of 'causal for Trait 2 only SNPs' captured by performing LASSO+ Stab. Selection to Trait 2


temp=unique(c(unname(temp1), unname(temp2)) ) # this is the total combined list of discovery by Trait 1 and Trait 2


sum(parse_number(causal_snps) %in% temp) # total number of causal discovery by Trait 1 and Trait 2 combined


